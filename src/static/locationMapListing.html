<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Location map listing </title>
  </head>
  <script type="module">
    function clearSessionStorage(){for(let t=0;t<sessionStorage.length;t++){const e=sessionStorage.key(t);sessionStorage.setItem(e,JSON.stringify({}))}}function getItemFromSessionStorage(t,e){const o=sessionStorage.getItem(t);if(!o)return null;const s=JSON.parse(o);return 0!==Object.keys(s).length&&e in s?s[e]:null}function updateSessionStorage(t,e,o){const s=sessionStorage.getItem(t);if(!s)throw new Error(`No cache defined for ${t}`);const n=JSON.parse(s);n[e]=o,sessionStorage.setItem(t,JSON.stringify(n))}function freezeState(t){if(!t||"{}"===JSON.stringify(t))return{};for(let[e,o]of Object.entries(t))t.hasOwnProperty(e)&&"object"==typeof o&&freezeState(o);return Object.freeze(t)}class DataStoreLoadAction{fetch(t,e){throw new Error(`fetch(params, cacheKey) method must be defined for ${this.constructor.name}`)}}class DataStore{static#t=0;#e=!1;#o=null;#s=[];#n;#i;constructor(t){this.#n=t,this.#s=[],this.#i=`data-store-${DataStore.#t}`,sessionStorage.setItem(this.#i,JSON.stringify({})),DataStore.#t++}getStoreData(){return this.#o}isWaitingForData(){return null!==this.#o&&void 0!==this.#o&&!this.#e}updateStoreData(t){this.#o={...this.#o,...freezeState(t)};for(let t=0;t<this.#s.length;t++)this.#s[t].updateFromSubscribedStores()}getSubscribedComponents(){return this.#s}async fetchData(t={},e){const o=this;if(!this.#e){this.#e=!0;const s=this.#n.getRequestConfig?this.#n.getRequestConfig(t):{};let n=null,i=null;if((o.#i||o.#i.length>0)&&(i=`${s.method??""}_${s.url}_${JSON.stringify(s.body)??""}`,n=getItemFromSessionStorage(this.#i,i)),null===n){for(let t=0;t<o.#s.length;t++)o.#s[t].lockComponent(o);if(e){const t=e.getSubscribedComponents();for(let o=0;o<t.length;o++)t[o].lockComponent(e)}n=await this.#n.fetch(t,o.#i,i),o.#o=n,o.#e=!1}else o.#o=n,o.#e=!1;for(let t=0;t<o.#s.length;t++)o.#s[t].unlockComponent(o),o.#s[t].updateFromSubscribedStores();if(e){const t=e.getSubscribedComponents();for(let o=0;o<t.length;o++)t[o].unlockComponent(e);e.updateStoreData(n)}return n}}unsubscribeComponent(t){const e=this.#s.indexOf(t);-1!==e?this.#s.splice(e,1):console.warn(`Attempt to unsubscribe ${t.constructor.name} from store it is not subscribed to`)}subscribeComponent(t){let e=0;for(;e<this.#s.length;){if(this.#s[e]===t){this.#s=this.#s.splice(e,1);break}e++}this.#s.push(t),this.isWaitingForData()||this.fetchData()}}class BaseDynamicComponent extends HTMLElement{#a=!1;#r=!1;#c=new Set;#d=0;componentStore={};#h;#l=[];constructor(t=[],e){super(),e&&(this.#h=e),this.#l=t;for(let t=0;t<this.#l.length;t++)this.#l[t].dataStore.subscribeComponent(this);this.updateFromSubscribedStores()}lockComponent(t){if(this.#c.has(t)?console.warn(`Attempting to lock component ${this.constructor.name} multiple times`):this.#c.add(t),0===this.#d&&(this.#d=Date.now()),this.#h){if(null===this.shadowRoot){this.attachShadow({mode:"open"});const t=document.createElement("template");this.shadowRoot.appendChild(t.content.cloneNode(!0))}this.shadowRoot.innerHTML=this.getTemplateStyle()+this.#h.generateLoadingIndicatorHtml()}}unlockComponent(t){this.#c.delete(t)}disconnectedCallback(){for(let t=0;t<this.#l.length;t++)this.#l[t].dataStore.unsubscribeComponent(this)}updateData(t){this.#r&&console.warn(`Attempting to trigger multiple renders at the same time on component ${this.constructor.name}`),t&&(this.#r=!0,this.componentStore={...this.componentStore,...freezeState(t)},this.#u(this.componentStore),this.shadowRoot&&this.attachHandlersToShadowRoot&&!this.#a&&(this.attachHandlersToShadowRoot(this.shadowRoot),this.#a=!0),this.#r=!1)}updateFromSubscribedStores(){let t=!0;for(let e=0;e<this.#l.length;e++)t=t&&this.#l[e].dataStore.isWaitingForData();if(t){let t={};for(let e=0;e<this.#l.length;e++){const o=this.#l[e];let s=o.dataStore.getStoreData();if(o.componentReducer&&(s=o.componentReducer(s)),o.fieldName)t[o.fieldName]=s;else if(t=s,this.#l?.length>1)throw new Error(`Component ${this.constructor.name} is subscribed to multiple data stores. \n              Each one must be associated with a specified field name`)}this.updateData(t)}}#u(t){if(null===this.shadowRoot){this.attachShadow({mode:"open"});const t=document.createElement("template");this.shadowRoot.appendChild(t.content.cloneNode(!0))}if(this.#d>0){const e=Date.now()-this.#d;if(console.log(`Loaded data for ${this.constructor.name} in ${e} milliseconds`),this.#d=0,this.#h?.minTimeMs){const o=this.#h.minTimeMs-e,s=this;o>0?setTimeout((()=>{s.shadowRoot.innerHTML=this.getTemplateStyle()+this.render(t)}),o):this.shadowRoot.innerHTML=this.getTemplateStyle()+this.render(t)}else this.shadowRoot.innerHTML=this.getTemplateStyle()+this.render(t)}else this.shadowRoot.innerHTML=this.getTemplateStyle()+this.render(t)}render(t){throw new Error(`render(data) function for ${this.constructor.name} must be defined`)}getTemplateStyle(){throw new Error(`getTemplateStyle function for ${this.constructor.name} must be defined`)}}class BaseTemplateComponent extends HTMLElement{connectedCallback(){this.attachShadow({mode:"open"});if(!this.shadowRoot)throw new Error("shadowRoot is not defined");const t=this.getTemplateStyle(),e=document.createElement("template");e.innerHTML=t+"<div></div>",this.shadowRoot.appendChild(e.content.cloneNode(!0));const o=this.shadowRoot?.querySelector("div");if(!o)throw new Error("Failed to create template with a <div></div> section");o.innerHTML=this.render(),this.attachEventHandlersToDom&&this.attachEventHandlersToDom(this.shadowRoot)}}const ApiActionType=Object.freeze({GET:"GET",POST:"POST",PUT:"PUT",DELETE:"DELETE"});function getLocalStorageDataIfPresent(t){const e=window.localStorage.getItem(t);return e?JSON.parse(e):null}function addLocalStorageData(t,e){window.localStorage.setItem(t,e)}function deleteLocalStoreData(t){window.localStorage.getItem(t)&&window.localStorage.removeItem(t)}class ApiLoadAction extends DataStoreLoadAction{#S;constructor(t){super(),this.#S=t}getRequestConfig(t){return this.#S(t)}async fetch(t,e,o){const s=this.#S(t);s.headers||(s.headers={});const n=await ApiLoadAction.getResponseData(s);return e&&o&&(s.method&&s.method!==ApiActionType.GET&&clearSessionStorage(),updateSessionStorage(e,o,n)),n}static async#m(t,e){let o;const s=t.headers.get("content-type");return o=s&&s.includes("application/json")?await t.json():404===t.status?`Endpoint ${e} not found`:await t.text(),{status:t.status,errorMessage:o,endpoint:e}}static async getResponseData(t){const e=getLocalStorageDataIfPresent("authToken")?.access_token;e&&(t.headers?t.headers.authToken=e:t.headers={authToken:e});try{const e=await fetch(t.url.replace(/"/g,""),{method:t.method??ApiActionType.GET,headers:t.headers,body:t.body});if(200!==e.status)return await this.#m(e,t.url);return"application/json"===e.headers.get("content-type")?await e.json():(t.method!==ApiActionType.GET&&(console.log("Clearing response cache and other data in session storage"),clearSessionStorage()),{status:200})}catch(t){return{errorMessage:t.message}}}}class CustomLoadAction extends DataStoreLoadAction{#p;constructor(t){super(),this.#p=t}async fetch(t){return await this.#p(t)}}export{ApiLoadAction,BaseDynamicComponent,BaseTemplateComponent,CustomLoadAction,DataStore,DataStoreLoadAction,addLocalStorageData,clearSessionStorage,deleteLocalStoreData,getLocalStorageDataIfPresent};
    class ListingComponent extends BaseDynamicComponent{
      getTemplateStyle() {
        return `
          <style>
            #dc-street-map {
              display: block;
              height: 50%;
              margin-top: 2rem;
              width: 50%;
              z-index: -10;
            }
            #success-message {
              color: #00bb51;
              font-weight: 600;
            }
            #status-section {
              height: 1rem;
            }
            .location-point {
              position: absolute;
              z-index:10;
                width: 30px;
  aspect-ratio: 1;
  background: #423600;
  clip-path: polygon(50% 0,
    calc(50%*(1 + sin(.4turn))) calc(50%*(1 - cos(.4turn))),
    calc(50%*(1 - sin(.2turn))) calc(50%*(1 - cos(.2turn))),
    calc(50%*(1 + sin(.2turn))) calc(50%*(1 - cos(.2turn))),
    calc(50%*(1 - sin(.4turn))) calc(50%*(1 - cos(.4turn)))
   );

            }

          </style>`
      }

      connectedCallback(){
        this.updateData({
          showInput: false
        });
      }

      attachHandlersToShadowRoot(shadowRoot){
        const self = this;
        shadowRoot.addEventListener("click",(event)=>{

          if(event.target.id === 'export-data-button') {
            const dataStr = JSON.stringify({...self.componentStore,statusMessage:""});

            const blob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(blob);

            const fileName = "locationsExport.json"
            const anchorEl = document.createElement("a");
            anchorEl.href = url;
            anchorEl.download = fileName;

            anchorEl.click();

            URL.revokeObjectURL(url);
          }

          if(event.target.id === 'import-data-button') {
            let files = self.shadowRoot.getElementById('select-import-file').files;
            if(files.length <=0){
              return;
            }

            let reader = new FileReader();

            reader.readAsText(files[0]);
            reader.onload = function () {
              if (reader.result !== null) {
                self.updateData(JSON.parse(reader.result))
              }
            };

          }

          if(event.target.id === 'delete-board-location'){

            const editingLocation = self.componentStore.editingLocation;
            let updatedLocations = [];

            for(let i=0;i<self.componentStore.locations.length;i++) {
              const item = self.componentStore.locations[i];
              if (item.displayX !== editingLocation.displayX || item.displayY !== editingLocation.displayY) {
                updatedLocations.push(item);
              }
            }

            self.updateData({
              editingLocation: null,
              locations: updatedLocations
            })
          }

          if(event.target.id === 'update-board-location'){

            let updatedLocations = self.componentStore.locations.slice();

            for(let i=0;i<updatedLocations.length;i++){
              const item = updatedLocations[i];
              if(item.displayX === editingLocation.displayX && item.displayY === editingLocation.displayY){
                updatedLocations[i] = {...item,locationName: shadowRoot.getElementById('location-name-input').value};;
              }
            }
            self.updateData({
              editingLocation: null,
              locations: updatedLocations,
            })
          }

          if(event.target.id === 'add-board-location'){
            let locationData = [];
            if(self.componentStore.locations){
              locationData = self.componentStore.locations.slice();
            }
            locationData.push({
              displayX: self.componentStore.mapClickX-15,
              displayY: self.componentStore.mapClickY-15,
              locationName: shadowRoot.getElementById('location-name-input').value,
            })
            self.updateData(
              {
                "locations":locationData,
                "statusMessage":"Added location",
              }
            )
          }

          if(event.target.className === 'location-point'){

            const x = parseInt(event.target.style.left.split("px")[0]);
            const y = parseInt(event.target.style.top.split("px")[0]);

            let editingLocation = null;
            for(let i = 0; i<self.componentStore.locations.length; i++){
              const item = self.componentStore.locations[i];
              if(item.displayX === x && item.displayY === y){
                editingLocation = item;
              }
            }

            self.updateData({
              editingLocation: editingLocation
            })

            event.preventDefault();
          }

          if(event.target.id === 'dc-street-map'){
            const clickX = event.clientX;
            const clickY = event.clientY;

            let offsetY = self.componentStore.offsetY;
            if(!self.componentStore.showInput){
              offsetY = event.target.getBoundingClientRect().y;
            }

            self.updateData({
              "mapClickX":clickX,
              "mapClickY":clickY,
              "offsetY":offsetY,
              "showInput":true
            })
          }
        })
      }

      getLocationDisplayHtml(data) {
        if(!data.locations){
          return ``;
        }

        let html = `<h2>Location list</h2><ul>`;
        for(let i=0; i<data.locations.length;i++){
          html+= `<li>${data.locations[i].locationName}</li>`;
        }
        html+= `</ul>`
        return html;
      }

      getLocationInputHtml(data){

        console.log("Updating with data:"+JSON.stringify(data));
        if(!data.showInput){
          return ``
        }

        if(data.editingLocation) {
          return `
          <label>Name of location</label>
          <input
            id="location-name-input"
            value="${data.editingLocation.locationName ?? ''}"
          >
          <button id="update-board-location">Update board location</button>
          <button id="delete-board-location">Delete board location</button>
        `
        }
        return `
          <label>Name of location</label>
          <input
            id="location-name-input"
            value="${data.name ?? ''}"
          >
          <button id="add-board-location">Add board location</button>
        `
      }

      showLocationsOnMap(data){

        if(data.locations){

          let html = `<div id="location-overlay" style="z-index: 10; top:${data.offsetY}px">`
          for(let i =0; i<data.locations.length; i++){
            const location = data.locations[i]
            html+= `<div class=location-point style="position: absolute;top:${location.displayY}px;left:${location.displayX}px">
            </div>`
          }

          html+= `<div>`;
          return html;
        }
        return ``
      }

      showStatusMessage(data){
        return `
          <div id="status-section">
               <p id="success-message">${data.statusMessage ?? ''}</p>

</div>
        `
      }

      showImportAndExportData(data){
        let html = `<div id="import-and-export">
          <input type="file" id="select-import-file"/>
          <button id ="import-data-button">Import data</button>
        `
        if(data.locations && data.locations.length > 0){
          html+=  `<button id="export-data-button">Export data</button>`
        }
        return html + `</div>`
      }

      render(data){
        return `
          <h1>A listing of community boards</h1>
          <p>Click on map to add or edit a location.</p>

          ${this.getLocationInputHtml(data)}
          ${this.showStatusMessage(data)}
          ${this.showImportAndExportData(data)}
          <div id = "map-container" >
            ${this.showLocationsOnMap(data)}
            <img id="dc-street-map" src="/images/dc/dc-street-map.jpg"></img>
          </div>
          Image from Ontheworldmap.com at <a href="https://ontheworldmap.com/usa/city/washington-dc/detailed-street-map-of-washington-dc.html">link</a>
                    ${this.getLocationDisplayHtml(data)}

        `
      }
    }
    customElements.define('listing-component',ListingComponent);
  </script>
<body>
  <listing-component></listing-component>
</body>
</html>